api:
  name: "spark_dsg"
  version: "1.1.1"
  description: "Python interface (Dynamic Scene Graph) library, a hierarchical representation for robotic perception. (import spark_dsg)"
  classes:
    - name: "DynamicSceneGraph"
      include: true
      description: "The main container for a multi-layered, dynamic scene graph. It manages all layers, nodes, and edges."
      constructor:
        include: true
        description: "Creates a new DynamicSceneGraph (dsg). Can be initialized empty, or with a predefined set of layers."
        inputs:
          - name: "empty"
            type: "bool"
            description: "If true, initializes an empty graph without default layers (optional, default=False)."
          - name: "layer_keys"
            type: "list[LayerKey]"
            description: "A list of layer keys to pre-allocate."
          - name: "layer_names"
            type: "dict[LayerId, str]"
            description: "A map from layer ID to layer name."
        example: |
          import spark_dsg as dsg
          # Create a graph with default layers
          graph = spark_dsg.DynamicSceneGraph()
          # Create a completely empty graph
          empty_graph = spark_dsg.DynamicSceneGraph(empty=True)
      methods:
        - name: "save"
          include: false
          description: "Saves the scene graph to a binary file."
          inputs:
            - name: "filepath"
              type: "str or pathlib.Path"
              description: "The path to the output file."
            - name: "include_mesh"
              type: "bool"
              description: "Whether to save the full mesh with the graph (optional, default=True)."
          output:
            type: "None"
            description: ""
          example: |
            graph.save("my_scene_graph.dsg")
        - name: "load"
          include: false
          description: "A static method to load a scene graph from a file."
          inputs:
            - name: "filepath"
              type: "str or pathlib.Path"
              description: "The path to the scene graph file."
          output:
            type: "DynamicSceneGraph"
            description: "The loaded scene graph object."
          example: |
            graph = spark_dsg.DynamicSceneGraph.load("my_scene_graph.dsg")
        - name: "has_layer"
          include: true
          description: "Checks if a layer exists in the graph."
          inputs:
            - name: "layer_id"
              type: "int or str"
              description: "The integer ID or string name of the layer."
            - name: "partition_id"
              type: "int"
              description: "The partition ID (optional, default=0)."
          output:
            type: "bool"
            description: "True if the layer exists, False otherwise."
          example: |
            exists = graph.has_layer(spark_dsg.DsgLayers.OBJECTS)
        - name: "get_layer"
          include: true
          description: "Gets a read-only view of a specific layer."
          inputs:
            - name: "layer_id"
              type: "str"
              description: "The string name of the layer to retrieve. (e.g (spark_dsg.DsgLayers.OBJECTS)"
          output:
            type: "LayerView"
            description: "A view of the requested layer. Throws an error if the layer does not exist."
          example: |
            objects_layer = graph.get_layer(spark_dsg.DsgLayers.OBJECTS)
        - name: "has_node"
          include: true
          description: "Checks if a node exists anywhere in the graph."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The unique identifier of the node."
          output:
            type: "bool"
            description: "True if the node exists, False otherwise."
          example: ""
        - name: "get_node"
          include: true
          description: "Gets a specific node from the graph."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The unique identifier of the node."
          output:
            type: "SceneGraphNode"
            description: "The requested node. Throws an error if the node does not exist."
          example: ""
        - name: "find_node"
          include: true
          description: "Finds a specific node in the graph, returning None if not found."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The unique identifier of the node."
          output:
            type: "SceneGraphNode or None"
            description: "The requested node, or None if it does not exist."
        - name: "has_edge"
          include: true
          description: "Checks if an edge exists between two nodes."
          inputs:
            - name: "source_node"
              type: "NodeSymbol"
              description: "The ID of the source node."
            - name: "target_node"
              type: "NodeSymbol"
              description: "The ID of the target node."
          output:
            type: "bool"
            description: "True if the edge exists, False otherwise."
          example: ""
        - name: "get_edge"
          include: true
          description: "Gets the edge between two nodes."
          inputs:
            - name: "source_node"
              type: "NodeSymbol"
              description: "The ID of the source node."
            - name: "target_node"
              type: "NodeSymbol"
              description: "The ID of the target node."
          output:
            type: "SceneGraphEdge"
            description: "The requested edge. Throws an error if the edge does not exist."
          example: ""
        - name: "find_edge"
          include: true
          description: "Finds the edge between two nodes, returning None if not found."
          inputs:
            - name: "source_node"
              type: "NodeSymbol"
              description: "The ID of the source node."
            - name: "target_node"
              type: "NodeSymbol"
              description: "The ID of the target node."
          output:
            type: "SceneGraphEdge or None"
            description: "The requested edge, or None if it does not exist."
        - name: "get_position"
          include: true
          description: "Gets the 3D position of a node. Important: This function expects the raw integer value of the NodeSymbol.
               Always pass `node.id.value` instead of `node.id`."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The ID of the node."
          output:
            type: "numpy.ndarray[3]"
            description: "The (x, y, z) position of the node."
          example: ""
        - name: "num_nodes"
          include: true
          description: "Gets the total number of nodes in the graph."
          inputs:
            - name: "include_partitions"
              type: "bool"
              description: "Whether to include nodes in partitioned layers (optional, default=True)."
          output:
            type: "int"
        - name: "num_edges"
          include: true
          description: "Gets the total number of edges in the graph."
          inputs:
            - name: "include_partitions"
              type: "bool"
              description: "Whether to include edges connected to partitioned layers (optional, default=True)."
          output:
            type: "int"
        - name: "empty"
          include: true
          description: "Checks if the graph has any nodes."
          output:
            type: "bool"
        - name: "clear"
          include: true
          description: "Removes all nodes, edges, and layers from the graph."
          output:
            type: "None"
        - name: "clone"
          include: true
          description: "Creates a deep copy of the scene graph."
          output:
            type: "DynamicSceneGraph"
      properties:
        - name: "nodes"
          include: true
          type: "iterator[SceneGraphNode]"
          description: "An iterator over all nodes in the graph (including partitions)."
          example: |
            for node in graph.nodes:
                print(node.id)
        - name: "unpartitioned_nodes"
          include: true
          type: "iterator[SceneGraphNode]"
          description: "An iterator over nodes in the graph, excluding layer partitions."
        - name: "edges"
          include: true
          type: "iterator[SceneGraphEdge]"
          description: "An iterator over all edges in the graph (including partitions)."
          example: |
            for edge in graph.edges:
                print(f"{edge.source} -> {edge.target}")
        - name: "unpartitioned_edges"
          include: true
          type: "iterator[SceneGraphEdge]"
          description: "An iterator over edges in the graph, excluding those connected to layer partitions."
        - name: "layers"
          include: true
          type: "iterator[LayerView]"
          description: "An iterator over all non-partitioned layers in the graph."
          example: |
            for layer in graph.layers:
                print(f"Layer {layer.id} has {layer.num_nodes()} nodes.")
        - name: "num_layers"
          include: true
          type: "int"
          description: "The total number of layers in the graph."
        - name: "mesh"
          include: true
          type: "Mesh"
          description: "The 3D mesh associated with the scene graph."
          access: "read-write"

    - name: "LayerView"
      include: true
      description: "A read-only view of a single layer within the DynamicSceneGraph."
      properties:
        - name: "id"
          include: true
          type: "int"
          description: "The unique integer identifier for this layer."
          access: "read-only"
        - name: "partition"
          include: true
          type: "int"
          description: "The partition identifier for this layer."
          access: "read-only"
        - name: "nodes"
          include: true
          type: "iterator[SceneGraphNode]"
          description: "An iterator over all nodes in this layer."
        - name: "edges"
          include: true
          type: "iterator[SceneGraphEdge]"
          description: "An iterator over all intra-layer edges in this layer."
      methods:
        - name: "num_nodes"
          include: true
          description: "Gets the number of nodes in this layer."
          output:
            type: "int"
        - name: "num_edges"
          include: true
          description: "Gets the number of intra-layer edges in this layer."
          output:
            type: "int"
        - name: "has_node"
          include: true
          description: "Checks if a node exists in this layer."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The ID of the node."
          output:
            type: "bool"
            description: "True if the node exists, False otherwise."
        - name: "get_node"
          include: true
          description: "Gets a node from this layer."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The ID of the node."
          output:
            type: "SceneGraphNode"
            description: "The requested node. Throws an error if not found."
        - name: "has_edge"
          include: true
          description: "Checks if an edge exists in this layer."
          inputs:
            - name: "source_node"
              type: "NodeSymbol"
              description: "The ID of the source node."
            - name: "target_node"
              type: "NodeSymbol"
              description: "The ID of the target node."
          output:
            type: "bool"
            description: "True if the edge exists, False otherwise."
        - name: "get_edge"
          include: true
          description: "Gets an edge from this layer."
          inputs:
            - name: "source_node"
              type: "NodeSymbol"
              description: "The ID of the source node."
            - name: "target_node"
              type: "NodeSymbol"
              description: "The ID of the target node."
          output:
            type: "SceneGraphEdge"
            description: "The requested edge. Throws an error if not found."
        - name: "get_position"
          include: true
          description: "Gets the 3D position of a node in this layer."
          inputs:
            - name: "node_id"
              type: "NodeSymbol"
              description: "The ID of the node."
          output:
            type: "numpy.ndarray[3]"
            description: "The (x, y, z) position of the node."

    - name: "SceneGraphNode"
      include: true
      description: "Represents a single node in the scene graph."
      properties:
        - name: "id"
          include: true
          type: "NodeSymbol"
          description: "The unique identifier for the node."
          access: "read-only"
        - name: "layer"
          include: true
          type: "int"
          description: "The ID of the layer this node belongs to."
          access: "read-only"
        - name: "attributes"
          include: true
          type: "NodeAttributes"
          description: "A container for the node's attributes (e.g., position). The actual type may be a subclass like SemanticNodeAttributes."
          access: "read-write"
      methods:
        - name: "has_parent"
          include: true
          description: "Checks if the node has a parent."
          output:
            type: "bool"
        - name: "has_siblings"
          include: true
          description: "Checks if the node has siblings."
          output:
            type: "bool"
        - name: "has_children"
          include: true
          description: "Checks if the node has children."
          output:
            type: "bool"
        - name: "get_parent"
          include: true
          description: "Gets the parent of the node, if one exists."
          output:
            type: "NodeSymbol or None"
        - name: "siblings"
          include: true
          description: "Gets a list of the node's siblings."
          output:
            type: "list[NodeSymbol]"
        - name: "children"
          include: true
          description: "Gets a list of the node's children."
          output:
            type: "list[NodeSymbol]"
        - name: "parents"
          include: true
          description: "Gets a list of the node's parents (can be more than one)."
          output:
            type: "list[NodeSymbol]"
        - name: "connections"
          include: true
          description: |
            Gets a list of all nodes connected to this one (parents and children).
            Note: `connections()` returns all connected nodes, including parents and children, which may be in different layers.
            To find adjacent nodes within the same layer (e.g., neighboring rooms), you must iterate through that layer's edges.
          output:
            type: "list[NodeSymbol]"

    - name: "SceneGraphEdge"
      include: true
      description: "Represents a directed edge between two nodes."
      properties:
        - name: "source"
          include: true
          type: "NodeSymbol"
          description: "The ID of the node where the edge originates."
          access: "read-only"
        - name: "target"
          include: true
          type: "NodeSymbol"
          description: "The ID of the node where the edge terminates."
          access: "read-only"
        - name: "info"
          include: true
          type: "EdgeAttributes"
          description: "A container for the edge's attributes (e.g., weight)."
          access: "read-write"

    - name: "NodeSymbol"
      include: true
      description: "A unique identifier for a node, composed of a character prefix and a numerical ID. E.g., 'p1' for place 1. (Case Sensitive)"
      constructor:
        include: true
        description: "Creates a new NodeSymbol."
        inputs:
          - name: "key"
            type: "char"
            description: "The character prefix for the category (e.g., 'p')."
          - name: "index"
            type: "int"
            description: "The numerical index for the node."
          - name: "value"
            type: "int"
            description: "A raw integer value to construct the symbol from."
        example: |
          node_id = spark_dsg.NodeSymbol('p', 10)
          node_id_from_val = spark_dsg.NodeSymbol(node_id.value)
      properties:
        - name: "category"
          include: true
          type: "str"
          description: "The character prefix of the symbol (e.g., 'p')."
          access: "read-only"
        - name: "category_id"
          include: true
          type: "int"
          description: "The numerical part of the symbol (e.g., 10)."
          access: "read-only"
        - name: "value"
          include: true
          type: "int"
          description: "The full integer representation of the symbol."
          access: "read-only"
      methods:
        - name: "str"
          include: true
          description: "Gets the string representation of the symbol."
          inputs:
            - name: "literal"
              type: "bool"
              description: "If true, show category name instead of char (optional, default=True)."
          output:
            type: "str"
            description: "The string label (e.g., 'p10')."
          example: |
            symbol = spark_dsg.NodeSymbol('p', 10)
            label = symbol.str() # 'p10'

    - name: "NodeAttributes"
      include: true
      description: "The base class for attributes associated with a node."
      constructor:
        include: true
        description: "Creates default node attributes."
        inputs: []
        example: ""
      properties:
        - name: "position"
          include: true
          type: "numpy.ndarray[3]"
          description: "The 3D position (x, y, z) of the node."
          access: "read-write"
        - name: "is_active"
          include: true
          type: "bool"
          description: "Whether the node is considered part of the active window."
          access: "read-write"
        - name: "is_predicted"
          include: true
          type: "bool"
          description: "Whether the node is a predicted entity."
          access: "read-write"
        - name: "last_update_time_ns"
          include: true
          type: "int"
          description: "Timestamp of the last update in nanoseconds."
          access: "read-write"

    - name: "SemanticNodeAttributes"
      include: true
      description: "Attributes for nodes with semantic meaning. Inherits from `NodeAttributes`."
      constructor:
        include: true
        description: "Creates default semantic node attributes."
        inputs: []
      properties:
        - name: "name"
          include: true
          type: "str"
          description: "A human-readable name for the node (e.g., 'object_1')."
          access: "read-write"
        - name: "color"
          include: true
          type: "numpy.ndarray[3]"
          description: "The RGB color of the node as a uint8 array."
          access: "read-write"
        - name: "bounding_box"
          include: true
          type: "BoundingBox"
          description: "The bounding box of the node."
          access: "read-write"
        - name: "semantic_label"
          include: true
          type: "int"
          description: "The semantic label ID for the node (e.g., from a segmentation model)."
          access: "read-write"
        - name: "semantic_feature"
          include: true
          type: "numpy.ndarray"
          description: "An arbitrary semantic feature vector for the node."
          access: "read-write"

    - name: "ObjectNodeAttributes"
      include: true
      description: "Attributes for object nodes. Inherits from `SemanticNodeAttributes`."
      constructor:
        include: true
        description: "Creates default object node attributes."
        inputs: []
      properties:
        - name: "registered"
          include: true
          type: "bool"
          description: "Whether the object has been registered against a database."
          access: "read-write"
        - name: "world_R_object"
          include: true
          type: "Quaternion"
          description: "The orientation of the object in the world frame."
          access: "read-write"
        - name: "mesh_connections"
          include: true
          type: "list[int]"
          description: "List of vertex indices from the scene mesh that belong to this object."
          access: "read-write"

    - name: "AgentNodeAttributes"
      include: false
      description: "Attributes for agent nodes (e.g., robot poses). Inherits from `NodeAttributes`."
      constructor:
        include: true
        description: "Creates default agent node attributes."
        inputs: []
      properties:
        - name: "world_R_body"
          include: true
          type: "Quaternion"
          description: "The orientation of the agent's body in the world frame."
          access: "read-write"
        - name: "timestamp"
          include: true
          type: "datetime.timedelta"
          description: "Timestamp of the agent's pose."
          access: "read-write"
        - name: "external_key"
          include: true
          type: "int"
          description: "An external key, often used for associating with other data (e.g., PGO)."
          access: "read-write"

    - name: "EdgeAttributes"
      include: true
      description: "A container for attributes associated with an edge."
      constructor:
        include: true
        description: "Creates default edge attributes."
        inputs: []
        example: ""
      properties:
        - name: "weighted"
          include: true
          type: "bool"
          description: "Indicates if the edge has a meaningful weight."
          access: "read-write"
        - name: "weight"
          include: true
          type: "float"
          description: "The weight of the edge, often used for pathfinding."
          access: "read-write"

    - name: "Color"
      include: false
      description: "Represents an RGBA color."
      constructor:
        include: true
        description: "Creates a new Color object with r, g, b, a components (0-255)."
        inputs: []
        example: |
          c = spark_dsg.Color()
          c.r = 255
          c.g = 0
          c.b = 0
          c.a = 255
      properties:
        - name: "r"
          include: true
          type: "int"
          description: "Red component."
          access: "read-write"
        - name: "g"
          include: true
          type: "int"
          description: "Green component."
          access: "read-write"
        - name: "b"
          include: true
          type: "int"
          description: "Blue component."
          access: "read-write"
        - name: "a"
          include: true
          type: "int"
          description: "Alpha component."
          access: "read-write"

    - name: "BoundingBox"
      include: true
      description: "Represents a 3D bounding box, which can be axis-aligned (AABB) or oriented (OBB)."
      constructor:
        include: true
        description: "Creates a new BoundingBox. Multiple constructors are available for different box types."
        inputs: []
        example: |
          import numpy as np
          # Create an AABB from min and max corners
          box = spark_dsg.BoundingBox(np.array([-1, -1, -1], dtype=np.float32), np.array([1, 1, 1], dtype=np.float32))
      properties:
        - name: "min"
          include: true
          type: "numpy.ndarray[3]"
          description: "The minimum corner of the box in the world frame."
          access: "read-only"
        - name: "max"
          include: true
          type: "numpy.ndarray[3]"
          description: "The maximum corner of the box in the world frame."
          access: "read-only"
        - name: "type"
          include: true
          type: "BoundingBoxType"
          description: "The type of bounding box (e.g., AABB, OBB)."
          access: "read-write"
        - name: "dimensions"
          include: true
          type: "numpy.ndarray[3]"
          description: "The (x, y, z) dimensions of the box."
          access: "read-write"
        - name: "world_P_center"
          include: true
          type: "numpy.ndarray[3]"
          description: "The position of the box's center in the world frame."
          access: "read-write"
        - name: "world_R_center"
          include: true
          type: "numpy.ndarray[3,3]"
          description: "The rotation matrix of the box's center in the world frame."
          access: "read-write"
      methods:
        - name: "is_valid"
          include: true
          description: "Checks if the bounding box is valid."
          output:
            type: "bool"
        - name: "volume"
          include: true
          description: "Computes the volume of the bounding box."
          output:
            type: "float"
        - name: "corners"
          include: true
          description: "Gets the 8 corners of the bounding box in the world frame."
          output:
            type: "list[numpy.ndarray[3]]"
        - name: "intersects"
          include: true
          description: "Checks if this bounding box intersects with another."
          inputs:
            - name: "other"
              type: "BoundingBox"
              description: "The other bounding box to check against."
          output:
            type: "bool"
      enums:
        - name: "BoundingBoxType"
          include: true
          values:
            - "INVALID"
            - "AABB" # Axis-aligned
            - "OBB"  # Oriented
            - "RAABB" # Rotated-Axis-aligned

    - name: "Mesh"
      include: false
      description: "Stores 3D mesh data, including vertices, colors, and faces."
      constructor:
        include: true
        description: "Creates a new, empty Mesh."
        inputs:
          - name: "has_colors"
            type: "bool"
            description: "Whether the mesh stores per-vertex colors."
          - name: "has_timestamps"
            type: "bool"
            description: "Whether the mesh stores per-vertex timestamps."
          - name: "has_labels"
            type: "bool"
            description: "Whether the mesh stores per-vertex semantic labels."
          - name: "has_first_seen_stamps"
            type: "bool"
            description: "Whether the mesh stores per-vertex first-seen timestamps."
        example: |
          mesh = spark_dsg.Mesh(has_colors=True, has_labels=True)
      methods:
        - name: "get_vertices"
          include: true
          description: "Gets the vertex data as a 6xN matrix."
          output:
            type: "numpy.ndarray[6, N]"
            description: "A float64 array where rows 0-2 are position (x,y,z) and rows 3-5 are color (r,g,b)."
        - name: "set_vertices"
          include: true
          description: "Sets the vertex data from a 6xN matrix."
          inputs:
            - name: "vertices"
              type: "numpy.ndarray[6, N]"
              description: "A float64 array where rows 0-2 are position (x,y,z) and rows 3-5 are color (r,g,b)."
        - name: "get_faces"
          include: true
          description: "Gets the mesh faces as a 3xM matrix."
          output:
            type: "numpy.ndarray[3, M]"
            description: "An int32 array of triangle indices."
        - name: "set_faces"
          include: true
          description: "Sets the mesh faces from a 3xM matrix."
          inputs:
            - name: "faces"
              type: "numpy.ndarray[3, M]"
              description: "An int32 array of triangle indices."
        - name: "empty"
          include: true
          description: "Checks if the mesh has any vertices."
          output:
            type: "bool"
        - name: "clear"
          include: true
          description: "Removes all vertices and faces from the mesh."
          output:
            type: "None"
        - name: "clone"
          include: true
          description: "Creates a deep copy of the mesh."
          output:
            type: "Mesh"

    - name: "Quaternion"
      include: true
      description: "A representation of a rotation in 3D space."
      constructor:
        include: true
        description: "Creates a new Quaternion."
        inputs:
          - name: "w"
            type: "float"
            description: "The real part."
          - name: "x"
            type: "float"
            description: "The first imaginary part."
          - name: "y"
            type: "float"
            description: "The second imaginary part."
          - name: "z"
            type: "float"
            description: "The third imaginary part."
        example: |
          # Identity rotation
          q = spark_dsg.Quaternion(1.0, 0.0, 0.0, 0.0)
      properties:
        - name: "w"
          include: true
          type: "float"
          description: "The w (real) component of the quaternion."
          access: "read-write"
        - name: "x"
          include: true
          type: "float"
          description: "The x component of the quaternion."
          access: "read-write"
        - name: "y"
          include: true
          type: "float"
          description: "The y component of the quaternion."
          access: "read-write"
        - name: "z"
          include: true
          type: "float"
          description: "The z component of the quaternion."
          access: "read-write"

  enums:
    - name: "DsgLayers"
      include: true
      description: |
        Standard integer identifiers for common semantic layers in the scene graph.
        Important: This is a class within the spark_dsg module, not an attribute of a 
        DynamicSceneGraph instance. Always reference it as `spark_dsg.DsgLayers`
        Incorrect: G.DsgLayers.OBJECTS
        Correct:   spark_dsg.DsgLayers.OBJECTS
      values:
        - name: "SEGMENTS"
          description: "Layer for mesh segments or supervoxels."
        - name: "OBJECTS"
          description: "Layer for individual objects."
        - name: "PLACES"
          description: "Layer for places (3D)"
        - name: "MESH_PLACES"
          description: "Layer for places defined by a collection of mesh vertices. (2D Places)"
        - name: "ROOMS"
          description: "Layer for rooms."
        - name: "BUILDINGS"
          description: "Layer for entire buildings or structures."
