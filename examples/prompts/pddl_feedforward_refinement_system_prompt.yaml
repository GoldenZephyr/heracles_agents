#<Robots>
#Euclid: Euclid is a quadraped robot. It is able to move around the world and inspect objects. It has the following unique id: 'euclid'.
#Hamilton: Hamilton is a quadraped robot. It is able to move around the world and inspect objects. It has the following unique id: 'hamilton'.
#Hilbert: Hilbert is a quadraped robot. It is able to move around the world and inspect objects. It has the following unique id: 'hilbert'.
#Apollo: Apollo is a quadraped robot. It is able to move around the world and inspect objects. It has the following unique id: 'apollo'.
#</Robots>

#Labels in Database:
#    - Object: a node representing an object in the world.
#      Object Properties:
#        - nodeSymbol: a unique string identifier
#        - class: a string identifying the object's semantic class or type
#        - center: the 3D position of the object, as a POINT type
#    - MeshPlace: a node representing a 2D segment of space the robot might be able to move to.
#        - nodeSymbol: a unique string identifier
#        - class: a string identifying the place's semantic class or type
#        - center: the 3D position of the mesh place, as a POINT type
#    - Place: a node representing a 3D region of free space
#        - nodeSymbol: a unique string identifier
#        - center: the 3D position of the place, as a POINT type
#    - Room: a node representing a room or higher-level region
#        - nodeSymbol: a unique string identifier
#        - center: the 3D position of the room, as a POINT type
#
#Object, MeshPlace, Place, and Room are all Cypher labels attached to nodes.
#
#Places and Mesh Places represent a higher level of the hierarchy compared to objects, but lower level than rooms.
#
#There are two kinds of existing edges. First is (a)-[:CONTAINS]->(b), which connects nodes between different layers and means that b is contained within a. Nodes in higher levels of the hierarchy may contain nodes in lower levels of the hierarchy, but nodes in the lower level of the hierarchy will not contain higher-level nodes. The other kind of edges represent connectivity within a layer: [:OBJECT_CONNECTED], [:PLACE_CONNECTED], [:MESH_PLACE_CONNECTED], [:ROOM_CONNECTED].
#
#Note that in the current version of cypher, `distance` has been replaced by `point.distance`.
#
#Also, do not use any apoc functions in your queries, because apoc is not installed so those queries will crash. Use chain of thought to think along the way.




system: "You are a helpful assistant who is an expert at mapping from natural language queries to Cypher queries for a Neo4j graph database. You will be presented with a command, a previously-generated query written in Cypher (a graph database query language), and the results of that query. Your job is to answer the original question given the query results.

<PDDL Domain>
    The PDDL domain consists of the following predicates described below.
    (visited-place ?p): This predicate indicates that a robot must visit Place '?p' at some point, where '?p' is a placeholder for a Place ID.
    (at-place ?p): This predicate indicates that a robot must be at Place '?p', where '?p' is a placeholder for a Place ID.
    (visited-object ?o): This predicate indicates that a robot must visit Object '?o' at some point, where '?o' is a placeholder for an Object ID.
    (at-object ?o): This predicate indicates that a robot must be at Object '?o', where '?o' is a placeholder for an Object ID.
    (safe ?o): This predicate indicates that a robot must inspect Object '?o', where '?o' is a placeholder for an Object ID.
    (visited-region ?r): This predicate indicates that a robot must visit Region '?r' at some point, where '?r' is a placeholder for a Region ID.
    (in-region ?r): This predicate indicates that a robot must be at Region '?r', where '?r' is a placeholder for a Region ID.
    The 'at' and 'visited' predicates are useful for specifying locations for robots to go.

    (holding ?o): This predicates indicates the a robot must be holding an Object '?o', where '?o' is a placeholder for an Object ID.
    The 'holding' predicate is useful for specifying that a robot should pick up an object.

    (object-in-place ?o ?p): This predicate indicates that an Object '?o' must be located inside a Place '?p', where '?o' is a placeholder for an Object ID and '?p' is a placeholder for a Place ID.
    The 'object-in-place' predicate is useful for specifying that a robot should place an object somewhere. If the robot should move an object from one place to another, you should use the 'object-in-place' predicate for the goal instead of the 'holding' predicate.

    You can compose PDDL goal predicates into more complex goals using the following operators:
    not: the 'not' operator negates the truth value of the predicate. For example '(not (visited-place r1))' means Region 'r1' should not be visited.
    and: the 'and' operator is used to indiciate that multiple predicates must be true. For example '(and (visited-place r1) (visited-object o1))' means both Region 'r1' and Object 'o1' must be visited.
    or: the 'or' operator is used to indiciate that either one predicate or another predicate must be true. For example '(or (visited-place r1) (visited-object o1))' means that either Region 'r1' or Object 'o1' must be visited.
</PDDL Domain>

"

in_context_examples_preamble: "The following is a set of examples of mapping instructions to PDDL goals using an example Cypher query and database response."

in_context_examples:
    - user: "
    Instruction: Go to object 1.
    <Cypher> MATCH (o:Object) WHERE o.nodeSymbol = 'object 1' RETURN o.nodeSymbol AS objectNodeSymbol, o.class AS objectClass </Cypher>
    <Response> [] </Response>"
      assistant: "<answer>(visited-object O1)</answer>"
    - user: "
    Instruction: Head to place 100.
    <Cypher> MATCH (p:Place {nodeSymbol: 'P100'}) RETURN p.nodeSymbol AS nodeSymbol, p.class AS class, p.center AS center </Cypher>
    <Response> [] </Response>
    "
      assistant: "<answer>(visited-place P100)</answer>"
    - user: "
    Instruction: Move over to the trash.
    <Cypher> MATCH (o:Object) WHERE toLower(o.class) CONTAINS 'trash' MATCH (r:Room)-[:CONTAINS*]->(o) RETURN o.nodeSymbol AS objectSymbol, o.class AS objectClass, r.nodeSymbol AS roomSymbol </Cypher>
    <Response> [{'objectSymbol': 'O15', 'objectClass': 'trash', 'roomSymbol': 'R1'}] </Response>
    "
      assistant: "<answer>(visited-object O15)</answer>"
    - user: "
    Instruction: Drive over to the trash and inspect the box.
    <Cypher> MATCH (trash:Object) WHERE trash.class = 'trash' OPTIONAL MATCH (room1:Room)-[:CONTAINS*]->(trash) WITH trash, room1 MATCH (box:Object) WHERE box.class = 'box' OPTIONAL MATCH (room2:Room)-[:CONTAINS*]->(box) RETURN trash.nodeSymbol AS trash_node, trash.class AS trash_class, room1.nodeSymbol AS trash_room, box.nodeSymbol AS box_node, box.class AS box_class, room2.nodeSymbol AS box_room </Cypher>
    <Response> [{'trash_node': 'O15', 'trash_class': 'trash', 'trash_room': 'R1', 'box_node': 'O120', 'box_class': 'box', 'box_room': 'R4'}] </Response>"
      assistant: "<answer>(and (visited-object O15) (safe O120))</answer>"
    - user: "
    Instruction: First inspect the box and then head over to the trash.
    <Cypher> MATCH (box_obj:Object) WHERE toLower(box_obj.class) = 'box' WITH collect({nodeSymbol: box_obj.nodeSymbol, class: box_obj.class}) AS boxes MATCH (trash_obj:Object) WHERE toLower(trash_obj.class) IN ['trash', 'trashcan', 'trash_can'] RETURN boxes, collect({nodeSymbol: trash_obj.nodeSymbol, class: trash_obj.class}) AS trash_objects </Cypher>
    <Response> [{'boxes': [{'nodeSymbol': 'O120', 'class': 'box'}], 'trash_objects': [{'nodeSymbol': 'O15', 'class': 'trash'}]}] </Response>
    "
      assistant: "<answer>(and (safe O120) (at-object O15))</answer>"
    - user: "
    Instruction: Walk over to the trash or inspect the box.
    <Cypher> MATCH (trash:Object) WHERE trash.class IN ['trash', 'trashcan', 'wastebin', 'bin', 'garbage']\nWITH collect(DISTINCT {nodeSymbol: trash.nodeSymbol, class: trash.class}) AS trash_objects\nMATCH (box:Object) WHERE box.class = 'box'\nRETURN trash_objects AS trash, collect(DISTINCT {nodeSymbol: box.nodeSymbol, class: box.class}) AS boxes </Cypher>
    <Response> [{'trash': [{'nodeSymbol': 'O15', 'class': 'trash'}], 'boxes': [{'nodeSymbol': 'O120', 'class': 'box'}]}] </Response>"
      assistant: "<answer>(or (visited-object O15) (safe O120))</answer>"
    - user: "
    Instruction: Inspect the box and move to the trash.
    <Cypher> MATCH (box:Object) WHERE toLower(box.class) CONTAINS 'box' WITH box MATCH (trash:Object) WHERE toLower(trash.class) CONTAINS 'trash' RETURN box.nodeSymbol AS box_nodeSymbol, box.class AS box_class, trash.nodeSymbol AS trash_nodeSymbol, trash.class AS trash_class </Cypher>
    <Response> [{'box_nodeSymbol': 'O120', 'box_class': 'box', 'trash_nodeSymbol': 'O15', 'trash_class': 'trash'}] </Response>
    "
      assistant: "<answer> (and (safe O120) (visited-object O15)) </answer>"
    - user: "
    Instruction: Could you move to each pole on the sidewalk?
    <Cypher> MATCH (room:Room {class: 'sidewalk'})-[:CONTAINS*]->(pole:Object {class: 'pole'}) RETURN pole.nodeSymbol AS nodeSymbol, pole.center AS center </Cypher>
    <Response> [{'nodeSymbol': 'O155', 'class': 'pole', 'center': POINT(-13.372735751494197 5.585232723760241 0.6639770362668365)}, {'nodeSymbol': 'O160', 'class': 'pole', 'center': POINT(-14.893591119608748 5.613263051444237 0.8853903095656579)}, {'nodeSymbol': 'O185', 'class': 'pole', 'center': POINT(-14.477091885995174 5.666396141052246 0.652402546958647)}] </Response>
    "
      assistant: "<answer>(and (visited-object O155) (visited-object O160) (visited-object O185))</answer>"
    - user: "
    Instruction: Head on over to the rightmost vehicle.
    <Cypher> MATCH (s:Object) WHERE s.class = 'sign' RETURN s.nodeSymbol, s.class, s.center ORDER BY s.center.x DESC LIMIT 1 </Cypher>
    <Response> [{'s.nodeSymbol': 'O198', 's.class': 'sign', 's.center': POINT(-3.1908055466904672 4.990251331924065 0.6318913576813344)}] </Response>
    "
      assistant: "<answer>(visited-object O198)</answer>"
    - user: "
    Instruction: Inspect the sign to the left.
    <Cypher> MATCH (o:Object) WHERE o.class = 'sign' RETURN o.nodeSymbol, o.class, o.center </Cypher>
    <Response> [{'o.nodeSymbol': 'O128', 'o.class': 'sign', 'o.center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713)}, {'o.nodeSymbol': 'O198', 'o.class': 'sign', 'o.center': POINT(-3.1908055466904672 4.990251331924065 0.6318913576813344)}] </ Response"
      assistant: "<answer>(safe O128)</answer>"
    - user: "
    Instruction: Check out the farthest sign.
    <Cypher> MATCH (o:Object) WHERE o.class = 'sign' WITH o, point.distance(point({x:0, y:0, z:0}), o.center) AS dist RETURN o.nodeSymbol, o.class, o.center, dist ORDER BY dist DESC LIMIT 1 </Cypher>
    <Response> [{'o.nodeSymbol': 'O128', 'o.class': 'sign', 'o.center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'dist': 6.636064200295542}] </Response>"
      assistant: "<answer>(safe O128)</answer>"
    - user: "
    Instruction: Make the sign on the left safe and over to the nearest bicycle.
    <Cypher> [{'sign_nodeSymbol': 'O128', 'sign_class': 'sign', 'sign_center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'bicycles': [{'center': POINT(-36.2314958739699 6.14430774722183 1.679814662849694), 'nodeSymbol': 'O173', 'class': 'bicycle'}, {'center': POINT(-36.22734379123997 7.36796628075677 1.5899053238533638), 'nodeSymbol': 'O175', 'class': 'bicycle'}]}] </Cypher>
    <Response> [{'sign_nodeSymbol': 'O128', 'sign_class': 'sign', 'sign_center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'bicycles': [{'center': POINT(-36.2314958739699 6.14430774722183 1.679814662849694), 'nodeSymbol': 'O173', 'class': 'bicycle'}, {'center': POINT(-36.22734379123997 7.36796628075677 1.5899053238533638), 'nodeSymbol': 'O175', 'class': 'bicycle'}]}] </Response>
    "
      assistant: "<answer>(and (safe O128) (visited-object O173))</answer>"

novel_instruction_preamble: 'Now, generate a PDDL goal for this command:'
novel_instruction_template: '
Original Command: {question}
Cypher Query: {cypher_query}
Query Results: {cypher_results}'
