system: |
  You are a helpful assistant who is an expert at assigning robots PDDL planning goals based on natural language commands grounded in 3D scene graphs. 
  You have access to a python API for SparkDSG representing a 3D scene graph, which stores spatial information that robot can use to understand the world. 
  Given a command, your task is to generate python code that retrieves the relevant information from the graph object. Then, use this information to formulate a PDDL goal for a robot.
  Given a 3D Scene Graph and an instruction, use the provided tool to query information from the scene graph. When you have enough information, submit your final answer.
  Use chain of thought to think along the way.

scene_graph_description: ${HERACLES_EVALUATION_PATH}/examples/prompts/common/scene_graph_description.yaml
labelspace_description: ${HERACLES_EVALUATION_PATH}/examples/prompts/common/building_45_labelspace.yaml
interface_description: ${HERACLES_EVALUATION_PATH}/examples/prompts/common/python_interface_description.yaml
domain_description: ${HERACLES_EVALUATION_PATH}/examples/prompts/common/pddl_domain_description.yaml

in_context_examples_preamble: "The following is a set of examples of mapping instructions to PDDL goals using an example Python code and code execution results."

#TODO FFINSIH  THESE
in_context_examples: |
  - user: "Go to object 1."
  <python> 
  def solve_task(G):
    # Return the NodeSymbol for object 1 (category 'O', index 1)
    obj_id = spark_dsg.NodeSymbol('O', 1)
    if G.has_node(obj_id):
        return obj_id
    return None
  </python>
  <Response> [] </Response>"
  assistant: "<answer>(visited-object O1)</answer>"
  - user: "Head to place 100."
    <python>
    def solve_task(G):
      """
      Returns the NodeSymbol for place 100 if it exists, otherwise None.
      """
      place_symbol = spark_dsg.NodeSymbol("P", 100)
      if G.has_node(place_symbol):
          return place_symbol

      return None
      </python>
    <Response> [] </Response>
    "
    assistant: "<answer>(visited-place P100)</answer>"
  - user: "Move over to the trash."
    <python>
    def solve_task(G):
      labelspace = G.metadata.get()["labelspace"]
      trash_nodes = []

      # Look through all objects and check their semantic label
      for obj in G.get_layer(spark_dsg.DsgLayers.OBJECTS).nodes:
          label_id = str(obj.attributes.semantic_label)
          if label_id in labelspace and "trash" in labelspace[label_id].lower():
              trash_nodes.append(obj.id)

      return trash_nodes
    </python>
    <Response> [O(15)] </Response>
    "
    assistant: "<answer>(visited-object O15)</answer>"
  - user: "Drive over to the trash and inspect the box."
    <python>
      def solve_task(G):
      labelspace = G.metadata.get()["labelspace"]
      trash_nodes = []
      box_nodes = []

      # Iterate over all objects in the graph
      for obj in G.get_layer(spark_dsg.DsgLayers.OBJECTS).nodes:
          label_id = str(obj.attributes.semantic_label)
          if label_id not in labelspace:
              continue

          label = labelspace[label_id].lower()
          if "trash" in label:
              trash_nodes.append(obj.id)
          elif "box" in label:
              box_nodes.append(obj.id)

      return {"trash": trash_nodes, "box": box_nodes}
    </python>
    <Response> {'trash': [O(15)], 'box': [O(120)]} </Response>
    "
    assistant: "<answer>(and (visited-object O15) (safe O120))</answer>"
  - user: "First inspect the box and then head over to the trash."
    <python>
    def solve_task_first_inspect_box_then_go_to_trash(G):
      """
      Task: First inspect the box and then head over to the trash.
      Returns two ordered lists of NodeSymbols: first for boxes, then for trash nodes.
      """

      labelspace = G.metadata.get()["labelspace"]
      box_nodes = []
      trash_nodes = []

      # Iterate over all objects in the graph
      for obj in G.get_layer(spark_dsg.DsgLayers.OBJECTS).nodes:
          label_id = str(obj.attributes.semantic_label)
          if label_id not in labelspace:
              continue

          label = labelspace[label_id].lower()
          if "box" in label:
              box_nodes.append(obj.id)
          elif "trash" in label:
              trash_nodes.append(obj.id)

      return {"box": box_nodes, "trash": trash_nodes}
    </python>
    <Response> {'box': [O(120)], 'trash': [O(15)]} </Response>
    "
    assistant: "<answer>(and (safe O120) (at-object O15))</answer>"
  - user: "Walk over to the trash or inspect the box."
    <python>
    def solve_task_walk_to_trash_or_inspect_box(G):
      labelspace = G.metadata.get()["labelspace"]
      trash_nodes = []
      box_nodes = []
      for obj in G.get_layer(spark_dsg.DsgLayers.OBJECTS).nodes:
          label_id = str(obj.attributes.semantic_label)
          if label_id not in labelspace:
              continue

          label = labelspace[label_id].lower()
          if "trash" in label:
              trash_nodes.append(obj.id)
          elif "box" in label:
              box_nodes.append(obj.id)

      return {"trash": trash_nodes, "box": box_nodes}
    </python>
    <Response> {'trash': [O(15)], 'box': [O(120)]} </Response>
    "
    assistant: "<answer>(or (visited-object O15) (safe O120))</answer>"
  - user: "Inspect the box and move to the trash."
    <python>
    def solve_task_trash_and_box(G):
      labelspace = G.metadata.get()["labelspace"]
      trash_nodes = []
      box_nodes = []

      # Iterate over all objects in the graph
      for obj in G.get_layer(spark_dsg.DsgLayers.OBJECTS).nodes:
          label_id = str(obj.attributes.semantic_label)
          if label_id not in labelspace:
              continue

          label = labelspace[label_id].lower()
          if "trash" in label:
              trash_nodes.append(obj.id)
          elif "box" in label:
              box_nodes.append(obj.id)

      return {"trash": trash_nodes, "box": box_nodes}
    </python>
    <Response> {'trash': [O(15)], 'box': [O(120)]} </Response>
    "
    assistant: "<answer> (and (safe O120) (visited-object O15)) </answer>"

#TODO Update these if we are using in-context examples
# in_context_examples:
#     - user: "
#     Instruction: Go to object 1.
#     <Cypher> MATCH (o:Object) WHERE o.nodeSymbol = 'object 1' RETURN o.nodeSymbol AS objectNodeSymbol, o.class AS objectClass </Cypher>
#     <Response> [] </Response>"
#       assistant: "<answer>(visited-object O1)</answer>"
#     - user: "
#     Instruction: Head to place 100.
#     <Cypher> MATCH (p:Place {nodeSymbol: 'P100'}) RETURN p.nodeSymbol AS nodeSymbol, p.class AS class, p.center AS center </Cypher>
#     <Response> [] </Response>
#     "
#       assistant: "<answer>(visited-place P100)</answer>"
#     - user: "
#     Instruction: Move over to the trash.
#     <Cypher> MATCH (o:Object) WHERE toLower(o.class) CONTAINS 'trash' MATCH (r:Room)-[:CONTAINS*]->(o) RETURN o.nodeSymbol AS objectSymbol, o.class AS objectClass, r.nodeSymbol AS roomSymbol </Cypher>
#     <Response> [{'objectSymbol': 'O15', 'objectClass': 'trash', 'roomSymbol': 'R1'}] </Response>
#     "
#       assistant: "<answer>(visited-object O15)</answer>"
#     - user: "
#     Instruction: Drive over to the trash and inspect the box.
#     <Cypher> MATCH (trash:Object) WHERE trash.class = 'trash' OPTIONAL MATCH (room1:Room)-[:CONTAINS*]->(trash) WITH trash, room1 MATCH (box:Object) WHERE box.class = 'box' OPTIONAL MATCH (room2:Room)-[:CONTAINS*]->(box) RETURN trash.nodeSymbol AS trash_node, trash.class AS trash_class, room1.nodeSymbol AS trash_room, box.nodeSymbol AS box_node, box.class AS box_class, room2.nodeSymbol AS box_room </Cypher>
#     <Response> [{'trash_node': 'O15', 'trash_class': 'trash', 'trash_room': 'R1', 'box_node': 'O120', 'box_class': 'box', 'box_room': 'R4'}] </Response>"
#       assistant: "<answer>(and (visited-object O15) (safe O120))</answer>"
#     - user: "
#     Instruction: First inspect the box and then head over to the trash.
#     <Cypher> MATCH (box_obj:Object) WHERE toLower(box_obj.class) = 'box' WITH collect({nodeSymbol: box_obj.nodeSymbol, class: box_obj.class}) AS boxes MATCH (trash_obj:Object) WHERE toLower(trash_obj.class) IN ['trash', 'trashcan', 'trash_can'] RETURN boxes, collect({nodeSymbol: trash_obj.nodeSymbol, class: trash_obj.class}) AS trash_objects </Cypher>
#     <Response> [{'boxes': [{'nodeSymbol': 'O120', 'class': 'box'}], 'trash_objects': [{'nodeSymbol': 'O15', 'class': 'trash'}]}] </Response>
#     "
#       assistant: "<answer>(and (safe O120) (at-object O15))</answer>"
#     - user: "
#     Instruction: Walk over to the trash or inspect the box.
#     <Cypher> MATCH (trash:Object) WHERE trash.class IN ['trash', 'trashcan', 'wastebin', 'bin', 'garbage']\nWITH collect(DISTINCT {nodeSymbol: trash.nodeSymbol, class: trash.class}) AS trash_objects\nMATCH (box:Object) WHERE box.class = 'box'\nRETURN trash_objects AS trash, collect(DISTINCT {nodeSymbol: box.nodeSymbol, class: box.class}) AS boxes </Cypher>
#     <Response> [{'trash': [{'nodeSymbol': 'O15', 'class': 'trash'}], 'boxes': [{'nodeSymbol': 'O120', 'class': 'box'}]}] </Response>"
#       assistant: "<answer>(or (visited-object O15) (safe O120))</answer>"
#     - user: "
#     Instruction: Inspect the box and move to the trash.
#     <Cypher> MATCH (box:Object) WHERE toLower(box.class) CONTAINS 'box' WITH box MATCH (trash:Object) WHERE toLower(trash.class) CONTAINS 'trash' RETURN box.nodeSymbol AS box_nodeSymbol, box.class AS box_class, trash.nodeSymbol AS trash_nodeSymbol, trash.class AS trash_class </Cypher>
#     <Response> [{'box_nodeSymbol': 'O120', 'box_class': 'box', 'trash_nodeSymbol': 'O15', 'trash_class': 'trash'}] </Response>
#     "
#       assistant: "<answer> (and (safe O120) (visited-object O15)) </answer>"
#     - user: "
#     Instruction: Could you move to each pole on the sidewalk?
#     <Cypher> MATCH (room:Room {class: 'sidewalk'})-[:CONTAINS*]->(pole:Object {class: 'pole'}) RETURN pole.nodeSymbol AS nodeSymbol, pole.center AS center </Cypher>
#     <Response> [{'nodeSymbol': 'O155', 'class': 'pole', 'center': POINT(-13.372735751494197 5.585232723760241 0.6639770362668365)}, {'nodeSymbol': 'O160', 'class': 'pole', 'center': POINT(-14.893591119608748 5.613263051444237 0.8853903095656579)}, {'nodeSymbol': 'O185', 'class': 'pole', 'center': POINT(-14.477091885995174 5.666396141052246 0.652402546958647)}] </Response>
#     "
#       assistant: "<answer>(and (visited-object O155) (visited-object O160) (visited-object O185))</answer>"
#     - user: "
#     Instruction: Head on over to the rightmost vehicle.
#     <Cypher> MATCH (s:Object) WHERE s.class = 'sign' RETURN s.nodeSymbol, s.class, s.center ORDER BY s.center.x DESC LIMIT 1 </Cypher>
#     <Response> [{'s.nodeSymbol': 'O198', 's.class': 'sign', 's.center': POINT(-3.1908055466904672 4.990251331924065 0.6318913576813344)}] </Response>
#     "
#       assistant: "<answer>(visited-object O198)</answer>"
#     - user: "
#     Instruction: Inspect the sign to the left.
#     <Cypher> MATCH (o:Object) WHERE o.class = 'sign' RETURN o.nodeSymbol, o.class, o.center </Cypher>
#     <Response> [{'o.nodeSymbol': 'O128', 'o.class': 'sign', 'o.center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713)}, {'o.nodeSymbol': 'O198', 'o.class': 'sign', 'o.center': POINT(-3.1908055466904672 4.990251331924065 0.6318913576813344)}] </ Response"
#       assistant: "<answer>(safe O128)</answer>"
#     - user: "
#     Instruction: Check out the farthest sign.
#     <Cypher> MATCH (o:Object) WHERE o.class = 'sign' WITH o, point.distance(point({x:0, y:0, z:0}), o.center) AS dist RETURN o.nodeSymbol, o.class, o.center, dist ORDER BY dist DESC LIMIT 1 </Cypher>
#     <Response> [{'o.nodeSymbol': 'O128', 'o.class': 'sign', 'o.center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'dist': 6.636064200295542}] </Response>"
#       assistant: "<answer>(safe O128)</answer>"
#     - user: "
#     Instruction: Make the sign on the left safe and over to the nearest bicycle.
#     <Cypher> [{'sign_nodeSymbol': 'O128', 'sign_class': 'sign', 'sign_center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'bicycles': [{'center': POINT(-36.2314958739699 6.14430774722183 1.679814662849694), 'nodeSymbol': 'O173', 'class': 'bicycle'}, {'center': POINT(-36.22734379123997 7.36796628075677 1.5899053238533638), 'nodeSymbol': 'O175', 'class': 'bicycle'}]}] </Cypher>
#     <Response> [{'sign_nodeSymbol': 'O128', 'sign_class': 'sign', 'sign_center': POINT(-4.228752903370042 5.018121605710045 0.9866369661580713), 'bicycles': [{'center': POINT(-36.2314958739699 6.14430774722183 1.679814662849694), 'nodeSymbol': 'O173', 'class': 'bicycle'}, {'center': POINT(-36.22734379123997 7.36796628075677 1.5899053238533638), 'nodeSymbol': 'O175', 'class': 'bicycle'}]}] </Response>
#     "
#       assistant: "<answer>(and (safe O128) (visited-object O173))</answer>"

novel_instruction_preamble: 'Now, generate a PDDL goal for this command:'
novel_instruction_template: '{question}'

answer_formatting_guidance: 'Use a series of steps to formulate your final answer in a chain of thought style. Your final PDDL goal should be written between two answer tags, <answer> and </answer>.'
